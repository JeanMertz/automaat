use crate::schema::sessions;
use diesel::prelude::*;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

/// The model representing a session stored in the database.
#[derive(Clone, Debug, Deserialize, Serialize, Identifiable, Queryable)]
#[table_name = "sessions"]
pub(crate) struct Session {
    pub(crate) id: i32,
    pub(crate) token: Uuid,
    pub(crate) privileges: Vec<String>,
}

impl Session {
    pub(crate) fn find_by_token(token: Uuid, conn: &PgConnection) -> QueryResult<Self> {
        sessions::table
            .filter(sessions::token.eq(token))
            .first(conn)
    }
}

/// Contains all the details needed to store a session in the database.
///
/// Use [`NewSession::new`] to initialize this struct.
#[derive(Clone, Debug, Deserialize, Serialize)]
pub(crate) struct NewSession<'a> {
    #[serde(borrow)]
    privileges: Vec<&'a str>,
}

impl<'a> NewSession<'a> {
    /// Initialize a `NewSession` struct, which can be inserted into the
    /// database using the [`NewSession#create`] method.
    pub(crate) const fn new(privileges: Vec<&'a str>) -> Self {
        Self { privileges }
    }

    /// Persist the session into the database.
    ///
    /// The session token is generated by the database itself.
    pub(crate) fn create(self, conn: &PgConnection) -> QueryResult<Session> {
        diesel::insert_into(sessions::table)
            .values(sessions::privileges.eq(self.privileges))
            .get_result(conn)
    }
}
